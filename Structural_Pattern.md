## Structural Pattern
### Introduction 
- Structural design patterns deal with the composition of classes or objects to form larger structures. These patterns focus on how classes and objects can be combined to create new structures while promoting flexibility, reusability, and maintainability. 
- Some common structural design patterns include:

1. **Adapter Pattern:**
   - Allows the interface of an existing class to be used as another interface.
   - It is often used to make existing classes work with others without modifying their source code.

2. **Bridge Pattern:**
   - Separates an abstraction from its implementation so that both can vary independently.
   - It is useful when you want to avoid a permanent binding between an abstraction and its implementation.

3. **Composite Pattern:**
   - Composes objects into tree structures to represent part-whole hierarchies.
   - It allows clients to treat individual objects and compositions of objects uniformly.

4. **Decorator Pattern:**
   - Attaches additional responsibilities to an object dynamically.
   - It provides a flexible alternative to subclassing for extending functionality.

5. **Facade Pattern:**
   - Provides a simplified interface to a set of interfaces in a subsystem.
   - It defines a higher-level interface that makes the subsystem easier to use.

6. **Flyweight Pattern:**
   - Minimizes memory usage or computational expenses by sharing as much as possible with other similar objects.
   - It is used to support a large number of similar objects efficiently.

7. **Proxy Pattern:**
   - Provides a surrogate or placeholder for another object to control access to it.
   - It is used when you want to add an extra level of control over the access to an object.

